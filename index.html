<!DOCTYPE html>
<html>
<head>
    <title>3D 2048</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #score {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #333;
            font-size: 24px;
            font-family: Arial;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 5px;
        }
        #instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #333;
            font-size: 16px;
            font-family: Arial;
            background: rgba(255,255,255,0.8);
            padding: 15px;
            border-radius: 5px;
            line-height: 1.5;
        }
        #gameOverModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            text-align: center;
            z-index: 1000;
        }
        
        #gameOverModal h2 {
            color: #333;
            margin-bottom: 20px;
        }
        
        #gameOverModal button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 15px;
        }
        
        #gameOverModal button:hover {
            background: #45a049;
        }
        
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        
        .control-button {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #4CAF50;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #333;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .control-button:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-2px);
        }
        
        .control-button.active {
            background: #4CAF50;
            color: white;
        }
    </style>
</head>
<body>
    <div id="score">åˆ†æ•°: 0</div>
    <div id="instructions">
        æ“ä½œè¯´æ˜ï¼š<br>
        â†‘ æˆ– Wï¼šå‘ä¸Šç§»åŠ¨<br>
        â†“ æˆ– Sï¼šå‘ä¸‹ç§»åŠ¨<br>
        â† æˆ– Aï¼šå‘å·¦ç§»åŠ¨<br>
        â†’ æˆ– Dï¼šå‘å³ç§»åŠ¨<br>
        Zï¼šå‘å‰ç§»åŠ¨<br>
        Xï¼šå‘åç§»åŠ¨<br>
        Rï¼šé‡æ–°å¼€å§‹æ¸¸æˆ<br>
        <br>
        è§†è§’æ§åˆ¶ï¼š<br>
        é¼ æ ‡æ‹–æ‹½ï¼šæ—‹è½¬è§†è§’<br>
        é¼ æ ‡æ»šè½®ï¼šç¼©æ”¾è§†è§’<br>
        <br>
        <span style="color: #c60000;">â€» çº¢è‰²ç®­å¤´æŒ‡å‘ç©å®¶æ—¶ä¸ºæ­£é¢</span>
    </div>
    
    <div id="controls">
        <button class="control-button" id="pauseButton">â¸ï¸ æš‚åœ</button>
        <button class="control-button" id="musicButton">ğŸµ éŸ³ä¹å¼€</button>
    </div>
    
    <div class="modal-overlay" id="modalOverlay"></div>
    <div id="gameOverModal">
        <h2>æ¸¸æˆç»“æŸï¼</h2>
        <p>ä½ çš„æœ€ç»ˆå¾—åˆ†æ˜¯ï¼š<span id="finalScore">0</span></p>
        <button id="restartButton">é‡æ–°å¼€å§‹</button>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.157.0/build/three.module.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';

        class OrbitControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.target = new THREE.Vector3();
                this.enabled = true;
                this.enableDamping = true;
                this.dampingFactor = 0.05;
                
                this.rotateSpeed = 1.0;
                this.zoomSpeed = 1.0;
                
                this.mouseButtons = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
                
                this.rotateStart = new THREE.Vector2();
                this.rotateEnd = new THREE.Vector2();
                this.rotateDelta = new THREE.Vector2();
                
                this.spherical = new THREE.Spherical();
                this.sphericalDelta = new THREE.Spherical();
                
                // æ·»åŠ æ§åˆ¶çŠ¶æ€æ ‡å¿—
                this.isControlling = false;
                
                // ä¿®æ”¹é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶å¤„ç†
                this.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.domElement.addEventListener('wheel', this.onMouseWheel.bind(this));
            }
            
            onMouseDown(event) {
                if (!this.enabled) return;
                
                event.preventDefault();
                
                // åˆ‡æ¢æ§åˆ¶çŠ¶æ€
                this.isControlling = !this.isControlling;
                
                if (this.isControlling) {
                    // å¼€å§‹æ§åˆ¶æ—¶è®°å½•èµ·å§‹ä½ç½®
                    this.rotateStart.set(event.clientX, event.clientY);
                    document.addEventListener('mousemove', this.onMouseMove.bind(this));
                    document.addEventListener('mouseup', this.onMouseUp.bind(this));
                    
                    // æ”¹å˜é¼ æ ‡æ ·å¼ä»¥æŒ‡ç¤ºå¯æ‹–åŠ¨çŠ¶æ€
                    this.domElement.style.cursor = 'grabbing';
                } else {
                    // åœæ­¢æ§åˆ¶æ—¶ç§»é™¤äº‹ä»¶ç›‘å¬
                    document.removeEventListener('mousemove', this.onMouseMove.bind(this));
                    document.removeEventListener('mouseup', this.onMouseUp.bind(this));
                    
                    // æ¢å¤é»˜è®¤é¼ æ ‡æ ·å¼
                    this.domElement.style.cursor = 'default';
                }
            }
            
            onMouseMove(event) {
                if (!this.isControlling) return;
                
                this.rotateEnd.set(event.clientX, event.clientY);
                this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
                
                const element = this.domElement;
                
                this.sphericalDelta.theta -= 2 * Math.PI * this.rotateDelta.x / element.clientWidth * this.rotateSpeed;
                this.sphericalDelta.phi -= 2 * Math.PI * this.rotateDelta.y / element.clientHeight * this.rotateSpeed;
                
                this.rotateStart.copy(this.rotateEnd);
                this.update();
            }
            
            onMouseUp() {
                document.removeEventListener('mousemove', this.onMouseMove.bind(this));
                document.removeEventListener('mouseup', this.onMouseUp.bind(this));
            }
            
            onMouseWheel(event) {
                if (!this.enabled || !this.isControlling) return;
                
                event.preventDefault();
                
                if (event.deltaY < 0) {
                    this.dollyIn();
                } else {
                    this.dollyOut();
                }
                
                this.update();
            }
            
            dollyIn() {
                this.camera.position.multiplyScalar(0.95);
            }
            
            dollyOut() {
                this.camera.position.multiplyScalar(1.05);
            }
            
            update() {
                const offset = new THREE.Vector3();
                offset.copy(this.camera.position).sub(this.target);
                
                this.spherical.setFromVector3(offset);
                
                this.spherical.theta += this.sphericalDelta.theta;
                this.spherical.phi += this.sphericalDelta.phi;
                
                this.spherical.phi = Math.max(0.01, Math.min(Math.PI - 0.01, this.spherical.phi));
                
                offset.setFromSpherical(this.spherical);
                
                this.camera.position.copy(this.target).add(offset);
                this.camera.lookAt(this.target);
                
                if (this.enableDamping) {
                    this.sphericalDelta.theta *= (1 - this.dampingFactor);
                    this.sphericalDelta.phi *= (1 - this.dampingFactor);
                } else {
                    this.sphericalDelta.set(0, 0, 0);
                }
            }
        }

        class Game3D2048 {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('gameCanvas'),
                    antialias: true
                });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0xE0F7FA);
                
                this.gridSize = 3;
                this.score = 0;
                
                // åˆå§‹åŒ–æ•°ç»„
                this.cubes = Array(this.gridSize).fill(null)
                    .map(() => Array(this.gridSize).fill(null)
                        .map(() => Array(this.gridSize).fill(0)));
                
                this.cubeObjects = Array(this.gridSize).fill(null)
                    .map(() => Array(this.gridSize).fill(null)
                        .map(() => Array(this.gridSize).fill(null)));
                
                this.camera.position.set(6, 6, 6);
                this.camera.lookAt(0, 0, 0);
                
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 10);
                
                const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight2.position.set(-10, -10, -10);
                
                this.scene.add(ambientLight);
                this.scene.add(directionalLight);
                this.scene.add(directionalLight2);
                
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                
                this.createGrid();
                this.addRandomNumber();
                this.addRandomNumber();
                
                // åˆ›å»ºæ–¹å‘æŒ‡ç¤ºç®­å¤´
                this.createDirectionArrow();
                
                document.addEventListener('keydown', this.handleKeyPress.bind(this));
                window.addEventListener('resize', this.onWindowResize.bind(this));
                
                // ä½¿ç”¨æ–°çš„éŸ³æ•ˆ
                this.mergeSound = new Audio('https://assets.mixkit.co/active_storage/sfx/2568/2568-preview.mp3');  // æ–¹å—åˆå¹¶éŸ³æ•ˆ
                this.resetSound = new Audio('https://assets.mixkit.co/active_storage/sfx/1115/1115-preview.mp3');   // æ›´çŸ­çš„é‡ç½®éŸ³æ•ˆï¼ˆä¸åˆ°1ç§’ï¼‰
                
                // é¢„åŠ è½½éŸ³æ•ˆ
                this.mergeSound.load();
                this.resetSound.load();
                
                // è°ƒæ•´éŸ³é‡
                this.mergeSound.volume = 0.2;
                this.resetSound.volume = 0.2;
                
                // æ·»åŠ é‡æ–°å¼€å§‹æŒ‰é’®çš„äº‹ä»¶ç›‘å¬
                document.getElementById('restartButton').addEventListener('click', () => {
                    this.resetGame();
                });
                
                // æ›´æ¢èƒŒæ™¯éŸ³ä¹ä¸ºæ›´è½»å¿«çš„éŸ³ä¹
                this.bgMusic = new Audio('https://assets.mixkit.co/active_storage/sfx/2392/2392-preview.mp3');
                this.bgMusic.loop = true;
                this.bgMusic.volume = 0.08;  // è°ƒä½éŸ³é‡
                
                // å½“éŸ³ä¹æ’­æ”¾ç»“æŸæ—¶è‡ªåŠ¨é‡æ–°å¼€å§‹
                this.bgMusic.addEventListener('ended', () => {
                    this.bgMusic.currentTime = 0;
                    this.bgMusic.play();
                });
                
                // æ¸¸æˆçŠ¶æ€
                this.isPaused = false;
                this.isMusicOn = true;
                
                // ç»‘å®šæ§åˆ¶æŒ‰é’®
                this.initializeControls();
                
                this.animate();
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            createGrid() {
                const spacing = 1.2;
                const gridGeometry = new THREE.BoxGeometry(1, 1, 1);
                const gridMaterial = new THREE.MeshPhongMaterial({
                    color: 0xBBDEFB,
                    transparent: true,
                    opacity: 0.2
                });
                
                for(let x = 0; x < this.gridSize; x++) {
                    for(let y = 0; y < this.gridSize; y++) {
                        for(let z = 0; z < this.gridSize; z++) {
                            const cube = new THREE.Mesh(gridGeometry, gridMaterial);
                            cube.position.set(
                                (x - this.gridSize/2 + 0.5) * spacing,
                                (y - this.gridSize/2 + 0.5) * spacing,
                                (z - this.gridSize/2 + 0.5) * spacing
                            );
                            this.scene.add(cube);
                        }
                    }
                }
            }

            addRandomNumber() {
                const available = [];
                for(let x = 0; x < this.gridSize; x++) {
                    for(let y = 0; y < this.gridSize; y++) {
                        for(let z = 0; z < this.gridSize; z++) {
                            if(this.cubes[x][y][z] === 0) {
                                available.push({x, y, z});
                            }
                        }
                    }
                }
                
                if(available.length > 0) {
                    const pos = available[Math.floor(Math.random() * available.length)];
                    const value = Math.random() < 0.9 ? 2 : 4;
                    this.cubes[pos.x][pos.y][pos.z] = value;
                    this.updateCube(pos.x, pos.y, pos.z, value, true);
                }
            }

            updateCube(x, y, z, value, isNew = false) {
                if (this.cubeObjects[x][y][z]) {
                    this.scene.remove(this.cubeObjects[x][y][z]);
                }

                const spacing = 1.2;
                const group = new THREE.Group();
                
                const cubeGeometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
                const color = this.getColorForNumber(value);
                const cubeMaterial = new THREE.MeshPhongMaterial({
                    color: color,
                    transparent: false,
                    shininess: 50,
                    specular: 0x444444,
                    emissive: color,
                    emissiveIntensity: 0.3  // å¢åŠ è‡ªå‘å…‰å¼ºåº¦
                });
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                group.add(cube);

                group.position.set(
                    (x - this.gridSize/2 + 0.5) * spacing,
                    (y - this.gridSize/2 + 0.5) * spacing,
                    (z - this.gridSize/2 + 0.5) * spacing
                );

                if (isNew) {
                    group.scale.set(0.1, 0.1, 0.1);
                    this.animateScale(group, 1);
                }

                this.scene.add(group);
                this.cubeObjects[x][y][z] = group;
                return group;
            }

            createNumberPoints(number) {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');

                // æ¸…ç©ºç”»å¸ƒ
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ç»˜åˆ¶æ•°å­—
                ctx.fillStyle = '#000000';
                const fontSize = number.toString().length > 2 ? 36 : 48;
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(number.toString(), canvas.width/2, canvas.height/2);

                // åˆ›å»ºç‚¹äº‘å‡ ä½•ä½“
                const geometry = new THREE.BufferGeometry();
                const positions = [];

                // ä»canvasä¸­é‡‡æ ·ç‚¹
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const step = 1; // æ¯ä¸ªåƒç´ éƒ½é‡‡æ ·
                
                for (let y = 0; y < canvas.height; y += step) {
                    for (let x = 0; x < canvas.width; x += step) {
                        const alpha = data[(y * canvas.width + x) * 4];
                        if (alpha < 128) { // é‡‡æ ·é»‘è‰²åƒç´ 
                            const xPos = (x - canvas.width/2) / (canvas.width/2) * 0.5;
                            const yPos = (canvas.height/2 - y) / (canvas.height/2) * 0.5;
                            positions.push(xPos, yPos, 0);
                        }
                    }
                }

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                return geometry;
            }

            getColorForNumber(number) {
                // åªä½¿ç”¨10ä¸ªæ•°å­—é˜¶æ®µï¼Œç§»é™¤3
                const numbers = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024];
                const index = numbers.indexOf(number);
                
                if (index === -1) return 0x888888; // æœªçŸ¥æ•°å­—ä½¿ç”¨ç°è‰²
                
                // é‡æ–°å®šä¹‰10ä¸ªé¢œè‰²ï¼Œæå‰æ‰€æœ‰é¢œè‰²ï¼Œæœ€ååŠ å…¥ç´«è‰²
                const colors = [
                    0x90FF90,    // éå¸¸æµ…çš„ç»¿è‰² (2)
                    0x00FF00,    // äº®ç»¿è‰² (4)
                    0xFFFF00,    // é»„è‰² (8)
                    0xFFC000,    // æ©™é»„è‰² (16)
                    0xFF8000,    // æ©™è‰² (32)
                    0xFF4000,    // æ·±æ©™è‰² (64)
                    0xFF0000,    // çº¢è‰² (128)
                    0xC00000,    // æ·±çº¢è‰² (256)
                    0x800000,    // æš—çº¢è‰² (512)
                    0x800080     // ç´«è‰² (1024)
                ];
                
                return colors[index];
            }

            handleKeyPress(event) {
                if (this.gameOver || this.isPaused) return;
                
                let moved = false;
                console.log('Key pressed:', event.key.toLowerCase());
                
                switch(event.key.toLowerCase()) {
                    case 'arrowleft':
                    case 'a':
                        moved = this.move('right');
                        break;
                    case 'arrowright':
                    case 'd':
                        moved = this.move('left');
                        break;
                    case 'arrowup':
                    case 'w':
                        moved = this.move('up');
                        break;
                    case 'arrowdown':
                    case 's':
                        moved = this.move('down');
                        break;
                    case 'z':
                        moved = this.move('forward');
                        break;
                    case 'x':
                        moved = this.move('backward');
                        break;
                    case 'r':
                        this.resetGame();
                        return;
                }

                if (moved) {
                    if (this.mergeSound) {
                        this.mergeSound.play().catch(e => console.log('Merge sound play failed:', e));
                    }
                    this.addRandomNumber();
                    if (!this.canMove()) {
                        this.gameOver = true;
                        this.showGameOver();
                    }
                }
            }

            move(direction) {
                let moved = false;
                const size = this.gridSize;
                const animations = [];
                
                // ç¡®å®šéå†é¡ºåº
                const iterations = {
                    'left':     { x: [0, size], y: [0, size], z: [0, size] },
                    'right':    { x: [size-1, -1], y: [0, size], z: [0, size] },
                    'up':       { y: [size-1, -1], x: [0, size], z: [0, size] },
                    'down':     { y: [0, size], x: [0, size], z: [0, size] },
                    'forward':  { z: [0, size], x: [0, size], y: [0, size] },
                    'backward': { z: [size-1, -1], x: [0, size], y: [0, size] }
                }[direction];

                // ç¡®ä¿ iterations å­˜åœ¨
                if (!iterations) {
                    console.error('Invalid direction:', direction);
                    return false;
                }

                for (let y = iterations.y[0]; y != iterations.y[1]; y += iterations.y[1] > iterations.y[0] ? 1 : -1) {
                    for (let x = iterations.x[0]; x != iterations.x[1]; x += iterations.x[1] > iterations.x[0] ? 1 : -1) {
                        for (let z = iterations.z[0]; z != iterations.z[1]; z += iterations.z[1] > iterations.z[0] ? 1 : -1) {
                            if (this.cubes[x][y][z] !== 0) {
                                const newPos = this.findTargetPosition(x, y, z, direction);
                                if (newPos.merged || newPos.x !== x || newPos.y !== y || newPos.z !== z) {
                                    const value = this.cubes[x][y][z];
                                    const oldCube = this.cubeObjects[x][y][z];
                                    
                                    // æ¸…é™¤åŸä½ç½®
                                    this.cubes[x][y][z] = 0;
                                    
                                    if (newPos.merged) {
                                        // åˆå¹¶åŠ¨ç”»
                                        const targetValue = value * 2;
                                        this.score += targetValue;
                                        this.cubes[newPos.x][newPos.y][newPos.z] = targetValue;
                                        
                                        animations.push(new Promise(resolve => {
                                            this.animateScale(oldCube, 0.1, () => {
                                                this.scene.remove(oldCube);
                                                const newCube = this.updateCube(newPos.x, newPos.y, newPos.z, targetValue, true);
                                                this.animateScale(newCube, 1.2, () => {
                                                    this.animateScale(newCube, 1, resolve);
                                                });
                                            });
                                        }));
                                    } else {
                                        // ç§»åŠ¨åŠ¨ç”»
                                        this.cubes[newPos.x][newPos.y][newPos.z] = value;
                                        if (oldCube) {
                                            const spacing = 1.2;
                                            const targetPos = new THREE.Vector3(
                                                (newPos.x - this.gridSize/2 + 0.5) * spacing,
                                                (newPos.y - this.gridSize/2 + 0.5) * spacing,
                                                (newPos.z - this.gridSize/2 + 0.5) * spacing
                                            );
                                            animations.push(this.animateMove(oldCube, targetPos));
                                            this.cubeObjects[newPos.x][newPos.y][newPos.z] = oldCube;
                                        }
                                    }
                                    this.cubeObjects[x][y][z] = null;
                                    moved = true;
                                }
                            }
                        }
                    }
                }

                // ç­‰å¾…æ‰€æœ‰åŠ¨ç”»å®Œæˆåå†æ·»åŠ æ–°æ•°å­—
                if (animations.length > 0) {
                    Promise.all(animations).then(() => {
                        this.addRandomNumber();
                        this.updateScore();
                    });
                } else if (moved) {
                    this.addRandomNumber();
                    this.updateScore();
                }

                return moved;
            }

            findTargetPosition(x, y, z, direction) {
                let newX = x, newY = y, newZ = z;
                let merged = false;
                const value = this.cubes[x][y][z];

                while (true) {
                    let nextX = newX, nextY = newY, nextZ = newZ;
                    
                    switch(direction) {
                        case 'left': nextX--; break;
                        case 'right': nextX++; break;
                        case 'up': nextY++; break;
                        case 'down': nextY--; break;
                        case 'forward': nextZ--; break;
                        case 'backward': nextZ++; break;
                        default:
                            console.error('Invalid direction in findTargetPosition:', direction);
                            return {x: newX, y: newY, z: newZ, merged: false};
                    }

                    if (!this.isValidPosition(nextX, nextY, nextZ)) break;
                    
                    if (this.cubes[nextX][nextY][nextZ] === 0) {
                        newX = nextX;
                        newY = nextY;
                        newZ = nextZ;
                    } else if (this.cubes[nextX][nextY][nextZ] === value && !merged) {
                        newX = nextX;
                        newY = nextY;
                        newZ = nextZ;
                        merged = true;
                        break;
                    } else {
                        break;
                    }
                }

                return {x: newX, y: newY, z: newZ, merged};
            }

            isValidPosition(x, y, z) {
                return x >= 0 && x < this.gridSize && 
                       y >= 0 && y < this.gridSize && 
                       z >= 0 && z < this.gridSize;
            }

            updateDisplay() {
                for(let x = 0; x < this.gridSize; x++) {
                    for(let y = 0; y < this.gridSize; y++) {
                        for(let z = 0; z < this.gridSize; z++) {
                            if(this.cubeObjects[x][y][z]) {
                                this.scene.remove(this.cubeObjects[x][y][z]);
                                this.cubeObjects[x][y][z] = null;
                            }
                            if(this.cubes[x][y][z] !== 0) {
                                this.updateCube(x, y, z, this.cubes[x][y][z]);
                            }
                        }
                    }
                }
            }

            updateScore() {
                document.getElementById('score').textContent = `åˆ†æ•°: ${this.score}`;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            animateScale(object, targetScale, onComplete) {
                const startScale = object.scale.x;
                const duration = 200; // åŠ¨ç”»æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
                const startTime = Date.now();

                const animate = () => {
                    const currentTime = Date.now();
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°ä½¿åŠ¨ç”»æ›´å¹³æ»‘
                    const eased = this.easeOutBack(progress);
                    const currentScale = startScale + (targetScale - startScale) * eased;
                    object.scale.set(currentScale, currentScale, currentScale);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else if (onComplete) {
                        onComplete();
                    }
                };

                animate();
            }

            easeOutBack(x) {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
            }

            // æ·»åŠ ç§»åŠ¨åŠ¨ç”»æ–¹æ³•
            animateMove(object, targetPos) {
                return new Promise(resolve => {
                    const startPos = object.position.clone();
                    const duration = 200;
                    const startTime = Date.now();

                    const animate = () => {
                        const currentTime = Date.now();
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);

                        const eased = this.easeOutQuad(progress);
                        object.position.lerpVectors(startPos, targetPos, eased);

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve();
                        }
                    };

                    animate();
                });
            }

            // æ·»åŠ ç¼“åŠ¨å‡½æ•°
            easeOutQuad(x) {
                return 1 - (1 - x) * (1 - x);
            }

            resetGame() {
                // éšè—å¼¹çª—
                const modal = document.getElementById('gameOverModal');
                const overlay = document.getElementById('modalOverlay');
                modal.style.display = 'none';
                overlay.style.display = 'none';
                
                // æ’­æ”¾é‡ç½®éŸ³æ•ˆ
                if (this.resetSound) {
                    this.resetSound.play().catch(e => console.log('Reset sound play failed:', e));
                }
                
                // æ¸…é™¤æ‰€æœ‰ç°æœ‰æ–¹å—
                for(let x = 0; x < this.gridSize; x++) {
                    for(let y = 0; y < this.gridSize; y++) {
                        for(let z = 0; z < this.gridSize; z++) {
                            if(this.cubeObjects[x][y][z]) {
                                this.scene.remove(this.cubeObjects[x][y][z]);
                                this.cubeObjects[x][y][z] = null;
                            }
                            this.cubes[x][y][z] = 0;
                        }
                    }
                }
                
                // é‡ç½®åˆ†æ•°
                this.score = 0;
                this.updateScore();
                
                // é‡ç½®æ¸¸æˆçŠ¶æ€
                this.gameOver = false;
                
                // é‡ç½®æš‚åœçŠ¶æ€
                this.isPaused = false;
                document.getElementById('pauseButton').textContent = 'â¸ï¸ æš‚åœ';
                document.getElementById('pauseButton').classList.remove('active');
                
                // æ·»åŠ ä¸¤ä¸ªåˆå§‹æ–¹å—
                this.addRandomNumber();
                this.addRandomNumber();
            }

            // æ·»åŠ åˆ›å»ºæ–¹å‘æŒ‡ç¤ºç®­å¤´çš„æ–¹æ³•
            createDirectionArrow() {
                const arrowGroup = new THREE.Group();
                
                // ä¿æŒç›¸åŒçš„ç®­å¤´å°ºå¯¸
                const bodyGeometry = new THREE.BoxGeometry(0.15, 0.4, 0.15);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xFF0000,
                    shininess: 50,
                    specular: 0x444444
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.2;
                
                const headGeometry = new THREE.ConeGeometry(0.2, 0.3, 4);
                const headMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xFF0000,
                    shininess: 50,
                    specular: 0x444444
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 0.55;
                head.rotation.y = Math.PI / 4;
                
                arrowGroup.add(body);
                arrowGroup.add(head);
                
                // è°ƒæ•´ç®­å¤´ä½ç½®å’Œæ–¹å‘ï¼Œä½¿å…¶æŒ‡å‘åæ–¹å‘ï¼ˆZè½´æ­£æ–¹å‘ï¼‰
                arrowGroup.position.set(0, 2.8, 0);
                arrowGroup.rotation.x = -Math.PI / 2;  // åè½¬ç®­å¤´æ–¹å‘
                
                this.scene.add(arrowGroup);
                this.arrow = arrowGroup;
            }

            canMove() {
                // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ç©ºæ ¼
                for(let x = 0; x < this.gridSize; x++) {
                    for(let y = 0; y < this.gridSize; y++) {
                        for(let z = 0; z < this.gridSize; z++) {
                            if(this.cubes[x][y][z] === 0) return true;
                            
                            // æ£€æŸ¥æ¯ä¸ªæ–¹å‘æ˜¯å¦å¯ä»¥åˆå¹¶
                            if (x < this.gridSize - 1 && this.cubes[x][y][z] === this.cubes[x + 1][y][z]) return true;
                            if (y < this.gridSize - 1 && this.cubes[x][y][z] === this.cubes[x][y + 1][z]) return true;
                            if (z < this.gridSize - 1 && this.cubes[x][y][z] === this.cubes[x][y][z + 1]) return true;
                        }
                    }
                }
                return false;
            }

            showGameOver() {
                const modal = document.getElementById('gameOverModal');
                const overlay = document.getElementById('modalOverlay');
                const finalScore = document.getElementById('finalScore');
                
                finalScore.textContent = this.score;
                modal.style.display = 'block';
                overlay.style.display = 'block';
            }

            initializeControls() {
                const pauseButton = document.getElementById('pauseButton');
                const musicButton = document.getElementById('musicButton');
                
                pauseButton.addEventListener('click', () => {
                    this.togglePause();
                });
                
                musicButton.addEventListener('click', () => {
                    this.toggleMusic();
                });
                
                // å¼€å§‹æ’­æ”¾èƒŒæ™¯éŸ³ä¹
                this.bgMusic.play().catch(e => console.log('Music play failed:', e));
            }
            
            togglePause() {
                this.isPaused = !this.isPaused;
                const pauseButton = document.getElementById('pauseButton');
                
                if (this.isPaused) {
                    pauseButton.textContent = 'â–¶ï¸ ç»§ç»­';
                    pauseButton.classList.add('active');
                } else {
                    pauseButton.textContent = 'â¸ï¸ æš‚åœ';
                    pauseButton.classList.remove('active');
                }
            }
            
            toggleMusic() {
                this.isMusicOn = !this.isMusicOn;
                const musicButton = document.getElementById('musicButton');
                
                if (this.isMusicOn) {
                    this.bgMusic.play();
                    musicButton.textContent = 'ğŸµ éŸ³ä¹å¼€';
                    musicButton.classList.remove('active');
                } else {
                    this.bgMusic.pause();
                    musicButton.textContent = 'ğŸ”‡ éŸ³ä¹å…³';
                    musicButton.classList.add('active');
                }
            }
        }

        window.onload = () => {
            const game = new Game3D2048();
        }
    </script>
</body>
</html>
